{
  "name": "father",
  "version": "0.10.6",
  "description": "A package parser that can resolve self and dependencies, supporting spm, component.",
  "main": "index",
  "dependencies": {
    "arale": "~0.2.0",
    "css-imports": "~0.3.0",
    "debug": "~1.0.2",
    "glob": "~4.0.2",
    "crequire": "~1.5.0",
    "semver": "~2.3.1",
    "extend": "~1.3.0",
    "vinyl": "~0.4.6",
    "mixarg": "~0.2.0"
  },
  "devDependencies": {
    "coveralls": "~2.8.0",
    "istanbul": "~0.2.6",
    "mocha": "~1.17.1",
    "should": "~4.0.4",
    "jshint": "2",
    "totoro": "1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/popomore/father"
  },
  "homepage": "https://github.com/popomore/father",
  "author": {
    "name": "popomore",
    "email": "sakura9515@gmail.com"
  },
  "license": "MIT",
  "scripts": {
    "test": "make test"
  },
  "readme": "# father [![Build Status](https://travis-ci.org/popomore/father.png?branch=master)](https://travis-ci.org/popomore/father) [![Coverage Status](https://coveralls.io/repos/popomore/father/badge.png?branch=master)](https://coveralls.io/r/popomore/father?branch=master)\n\nA package parser that can resolve self and dependencies, supporting [spm](https://github.com/spmjs/spm) / [component](https://github.com/component/component).\n\n---\n\n## Install\n\n```\n$ npm install father -g\n```\n\n## Usage\n\n```\n// using SpmPackage\nvar Package = require('father').SpmPackage;\nvar pkg = new Package('path/to/package')\nconsole.log(pkg.name);\nconsole.log(pkg.version);\nconsole.log(pkg.main);\nconsole.log(pkg.dependencies); // return a object contains dependencies\nconsole.log(pkg.get('each')); // return a package named each\n\n// using ComponentPackage\nvar Package = require('father').ComponentPackage;\n```\n\n## Properties\n\nThe properties of Package instance\n\n### pkg.id\n\nUnique id for each package\n\n`= {pkg.name}@{pkg.version}`\n\n### pkg.name `require`\n\nPackage's name\n\n### pkg.version `require`\n\nPackage's version\n\n### pkg.main\n\nEntry point of the package, default is `index.js`\n\n### pkg.dependencies\n\nPackage's dependencies, each one will return a Package instance\n\n### pkg.files\n\nAll used files will exist in pkg.files, it will be parsed from pkg.main. Each file contains dependent files (no deep dependencies).\n\nExample below\n\n```\n{\n  files: {\n    'index.js': {\n      dependencies: ['each', './feature']\n    }\n  }\n}\n```\n\n### pkg.dest\n\nThe base directory of the package\n\n### pkg.origin\n\nThe origin package info\n\n### pkg.output\n\nExport files when build\n\n## Method\n\n### pkg.getPackage(pkg.id)\n\nGet a package by id\n\n### pkg.setPackage(pkg)\n\nSet a package\n\n### pkg.getPackages()\n\nGet all dependent packages\n\n### pkg.getFile(fullpath)\n\nGet file object by given path\n\n### pkg.getFiles()\n\nGet all file objects\n\n## Options\n\nThe options when instantiation\n\n```\nnew Package('path/to/package', options);\n```\n\n### entry\n\nGenerally, files will be parsed from pkg.main, no dependent file will not be included. `entry` will be another entry point.\n\nFiles\n\n```\n// a.js <- pkg.main\nconsole.log('no require');\n\n// b.js\nrequire('./c');\n\n// c.js\nconsole.log('no require');\n```\n\nCode\n\n```\nnew Package('path/to/package', {\n  entry: ['b.js']\n});\n```\n\nReturn\n\n```\n// without entry\n{\n  ...\n  files: {\n    'a.js': []\n  }\n}\n\n// with entry\n{\n  ...\n  files: {\n    'a.js': [],\n    'b.js': ['./c'],\n    'c.js': []\n  }\n}\n```\n\n### skip\n\n```\n// a.js\nrequire('b')\n```\n\nIf you want to skip file or package, you can specify skip. And it won't parse b and won't exist in dependencies.\n\n```\nnew Package('path/to/package', {\n  skip: ['b']\n});\n```\n\nyield\n\n```\ndefine('a', [], function(require) {\n  require('b')\n});\n```\n\n### ignore\n\nAlmost same as skip, however it will exist in dependency.\n\n### moduleDir\n\nWhere is your modules\n\n## File object\n\nwhat you get in pkg.files is file objects that is extending [vinyl](https://github.com/wearefractal/vinyl).\n\n```\nvar fileObj = pkg.files['a.js'];\nfileObj.pkg\nfileObj.relative\nfileObj.extension\nfileObj.path // = fileObj.pkg.dest + fileObj.relative\n```\n\n### lookup\n\nlookup all dependencies and can be filtered or transformed in callback\n\n```\nfileObj.lookup(function(fileInfo) {\n  // fileInfo.path: filepath of fileinfo\n  // fileInfo.relative: filepath based on packagge\n  // fileInfo.pkg: package info\n  // fileInfo.isRelative: required by file in the same package\n  // fileInfo.dependent: dependent package\n  // fileInfo.extension: exntesion of the file\n  return fileInfo.filepath;\n\n  return false; // ignore\n});\n```\n\n### hasExt\n\nDetermine whether it has the matched extension in all dependencies.\n\n```\nfileObj.hasExt('css'); // return false\n```\n\n## Custom\n\nIf you want to use it for your package, you can extend Package and override readPackage.\n\n```\nvar Package = require('father').Package;\nvar Custom = Package.extend({\n  readPackage: function() {\n    // 1. read config file, E.g. component.json\n    // 2. return a package contains id, name, version, dependencies, main, dest, files, origin\n    // 3. dependencies should contain id, name, version, dest\n  };\n})\n```\n\nExample for returned object by readPackage\n\n```\n{\n  id: 'a',\n  name: 'a'  \n  version: '1.0.0',\n  main: 'index.js',\n  dest: '/home/user/a',\n  dependencies: {\n    b: {\n      id: 'b@1.1.0',\n      name: 'b',\n      version: '1.1.0',\n      dest: '/home/user/a/components/b'\n    }\n  }\n}\n```\n\n## LISENCE\n\nCopyright (c) 2014 popomore. Licensed under the MIT license.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/popomore/father/issues"
  },
  "_id": "father@0.10.6",
  "_from": "father@~0.10.0"
}
